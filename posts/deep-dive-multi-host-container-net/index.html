<!DOCTYPE html><html lang="en-US" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Containers from Scratch: Deep Dive into Multi-Host Container Networking (Part II)" /><meta property="og:locale" content="en_US" /><meta name="description" content="This article is Part II of the previously published article, Containers from Scratch: Deep Dive into Single-Host Container Networking. In Part I, you’ve learned how two containers communicate on the same single host, also known as Single-host container networking." /><meta property="og:description" content="This article is Part II of the previously published article, Containers from Scratch: Deep Dive into Single-Host Container Networking. In Part I, you’ve learned how two containers communicate on the same single host, also known as Single-host container networking." /><link rel="canonical" href="https://zawzaw.blog/posts/deep-dive-multi-host-container-net/" /><meta property="og:url" content="https://zawzaw.blog/posts/deep-dive-multi-host-container-net/" /><meta property="og:site_name" content="Zaw Zaw" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-05-25T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Containers from Scratch: Deep Dive into Multi-Host Container Networking (Part II)" /><meta name="twitter:site" content="@zawzaw_me" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-05-25T00:00:00+00:00","datePublished":"2025-05-25T00:00:00+00:00","description":"This article is Part II of the previously published article, Containers from Scratch: Deep Dive into Single-Host Container Networking. In Part I, you’ve learned how two containers communicate on the same single host, also known as Single-host container networking.","headline":"Containers from Scratch: Deep Dive into Multi-Host Container Networking (Part II)","mainEntityOfPage":{"@type":"WebPage","@id":"https://zawzaw.blog/posts/deep-dive-multi-host-container-net/"},"url":"https://zawzaw.blog/posts/deep-dive-multi-host-container-net/"}</script><title> Containers from Scratch: Deep Dive into Multi-Host Container Networking (Part II) | Zaw Zaw</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/images/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/images/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Zaw Zaw"><meta name="application-name" content="Zaw Zaw"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/images/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.0/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/images/favicons/favicon-16x16.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Zaw Zaw</a></div><div class="site-subtitle font-italic">ZAW's Library & Personal Blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/photography/" class="nav-link"> <i class="fa-fw fas fa-image ml-xl-3 mr-xl-3 unloaded"></i> <span>PHOTOGRAPHY</span> </a><li class="nav-item"> <a href="/contact/" class="nav-link"> <i class="fa-fw fas fa-phone ml-xl-3 mr-xl-3 unloaded"></i> <span>CONTACT</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT ME</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/zawzaww" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://x.com/zawzaw_me" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-x-twitter"></i> </a> <a href="https://www.linkedin.com/in/zawzaww" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.instagram.com/zawzaw.me" aria-label="instagram" target="_blank" rel="noopener"> <i class="fab fa-instagram"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['zawzthein','outlook.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Containers from Scratch: Deep Dive into Multi-Host Container Networking (Part II)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Containers from Scratch: Deep Dive into Multi-Host Container Networking (Part II)</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Containers from Scratch: Deep Dive into Multi-Host Container Networking (Part II)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Zaw Zaw </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, May 25, 2025, 12:00 AM +0000" prep="on" > May 25 <i class="unloaded">2025-05-25T00:00:00+00:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3188 words">17 min</span></div></div><div class="post-content"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/featured-images/img_container_networking.png" class="preview-img" alt="Preview Image"><p align="center"> <span class="caption" style="font-size: 14px; font-weight: 500; font-style: oblique;"> Container Networking Featured Photo </span></p><p>This article is Part II of the previously published article, <a href="https://www.zawzaw.blog/posts/deep-dive-single-host-container-net">Containers from Scratch: Deep Dive into Single-Host Container Networking</a>. In Part I, you’ve learned how two containers communicate on the same single host, also known as <strong>Single-host</strong> container networking.</p><p>In this article, Part II, you’ll learn how Containers <em>(Container A and Container B)</em> running on two different hosts (VMs) communicate and interact with each other using VXLAN networking, also known as <strong>Multi-host</strong> container networking, and I’ll also demonstrate how Multi-host container networking works at the underlying layer with built-in Linux command-line tools.</p><h2 id="summary-objectives">Summary: Objectives</h2><p><em>What you’ll learn in this article:</em></p><ul><li><p>Basic Multi-Host Networking concepts</p><li><p>Basic Concepts of Kubernetes CNI (Container Network Interface) plugins</p><li><p>What’s VXLAN (Virtual eXtensible Local-Area Network) and how it works</p><li><p>How Containers running on Different Hosts communicate and interact using VXLAN networking</p></ul><h2 id="prerequisites">Prerequisites</h2><p>Before you begin, make sure you’ve installed the following tools:</p><ul><li>Linux-based Two VMs (or) Servers<li>Basic Networking Concepts<li>Familiar with Linux networking tools, such as <code class="language-plaintext highlighter-rouge">ip</code> and <code class="language-plaintext highlighter-rouge">brctl</code></ul><hr /><h2 id="overview-of-multi-host-container-networking">Overview of Multi-host Container Networking</h2><p>You’ve previously learned how two containers communicate on the same single host, only one host (or) VM, also known as Single-host container networking. For example, Docker single host.</p><blockquote><p>In Multi-host container networking facilitated by overlay networks, containers running on the different hosts (or) VMs can communicate with each other in the same network. Sometimes, we refer to it as Multi-node (or) Cluster networking. For example, Docker Swarm mode, Kubernetes.</p></blockquote><p>Technically, we can use two different networking methods for Multi-host container networking.</p><ul><li><p><strong>VXLAN (Virtual eXtensible Local-Area Network)</strong> is a tunneling protocol or network virtualization technology that provides tunneling a virtual Layer 2 network (overlay network) over the Layer 3 network (underlay network).</p><li><p><strong>Direct Routing (also known as Native or Simple Routing)</strong> is the Linux kernel’s built-in capabilities for forwarding network packets between different networks, rather than using specific software or network protocols. That means it’s no encapsulation, no overlay network. It’s just simple IP routing.</p></ul><p>For Example, the following Kubernetes CNI (Container Network Interface) plugins use different networking modes. But some Kubernetes CNIs provide both VXLAN (Encapsulation) and Direct Routing (or Native Routing) modes.</p><ul><li><p><a href="https://github.com/flannel-io/flannel/">Flannel</a>: VXLAN is the default networking mode of Flannel.</p><li><p><a href="https://docs.tigera.io/calico/">Calico</a>: Calico’s default networking mode is BGP (Border Gateway Protocol) or Direct Routing, but you can also use the VXLAN networking mode.</p><li><p><a href="https://docs.cilium.io/en/stable/">Cilium</a>: Cilium also provides both VXLAN and Direct Routing (or Native Routing) modes. But the default networking mode is VXLAN or tunnel mode, also known as encapsulation mode.</p><li><p><a href="https://www.kube-router.io/docs/">Kube-router</a>: The default networking mode of Kube-router is BGP or Direct Routing (or Native Routing) as the main routing mechanism and so on.</p></ul><p>You can see the CNI full list on <a href="https://github.com/containernetworking/cni?tab=readme-ov-file#3rd-party-plugins">https://github.com/containernetworking/cni?tab=readme-ov-file#3rd-party-plugins</a>.</p><p>In this article, I will focus on <strong>VXLAN Networking</strong> to demonstrate Multi-host container networking from scratch.</p><hr /><h2 id="whats-vxlan-and-how-it-works">What’s VXLAN and How it Works</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/featured-images/img_vxlan_diagram.png" alt="vxlan-diagram" /> <em>Photo Credit to: RedHat Developers (developers.redhat.com)</em></p><p><strong>VXLAN (Virtual eXtensible Local-Area Network)</strong> is a tunneling protocol or network virtualization technology that provides for creating a virtual Layer 2 network (overlay network) over the Layer 3 network (underlay network).</p><ul><li><p><strong>An Overlay Network</strong> is a virtual or logical network built on top of an existing physical network (also known as underlay network). It provides services, such as network virtualization, segmentation, and tunneling. For examples; VPNs, VXLAN.</p><li><p><strong>An Underlay Network</strong> is the physical network infrastructure that provides the actual connectivity. For example; network routers, switches.</p></ul><p>VXLAN encapsulates the Layer 2 Ethernet frames into UDP packets. This enables Layer 2 network (the data link layer, e.g: switch) traffic to traverse a Layer 3 network (the network layer, e.g; router and IP address). It’s especially used in data centers, cloud environments, scalable overlay networks for VMs, and containers.</p><h3 id="use-cases">Use Cases</h3><p>There are example use cases of VXLAN:</p><ul><li>Cloud Networking — Connecting VMs across hosts.<li>Container Networking — Kubernetes CNI (Container Network Interface) plugins.</ul><h3 id="vxlan-components">VXLAN Components</h3><p>There are key components of VXLAN:</p><ul><li><p><strong>VXLAN Tunnel Endpoint (VTEP)</strong>: This is the core component that performs the encapsulation and decapsulation of VXLAN packets. VTEPs can be physical network devices or virtual switches within hypervisors (e.g: VMware). Each VTEP has a unique IP address in the underlay network.</p><li><p><strong>VXLAN Network Identifier (VNI)</strong>: This is a 24-bit identifier that uniquely identifies each virtual network segment within the VXLAN overlay.</p><li><p><strong>Underlay Network</strong>: This is the physical network that VXLAN traffic traverses. It provides the routing infrastructure for the encapsulated VXLAN packets.</p><li><p><strong>Overlay Network</strong>: This is the virtual network created by VXLAN, running on top of the underlay physical network. It allows VMs (or Servers) to communicate.</p></ul><h3 id="how-vxlan-works">How VXLAN Works</h3><p>Basically, <strong>VXLAN (Virtual eXtensible Local-Area Network)</strong> works by encapsulating L2 Ethernet frames in UDP/IP with VTEPs handling the mapping between virtual overlay and physical underlay networks.</p><p>Simple Usage:</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ip <span class="nb">link </span>add &lt;vx0&gt; <span class="nb">type </span>vxlan <span class="nb">id </span>100 <span class="nb">local</span> &lt;10.0.0.100&gt; remote &lt;10.0.0.200&gt; dev eth0 dstport 4789
</pre></table></code></div></div><h4 id="setup-1-frame-arrival">Setup (1): Frame Arrival</h4><ul><li>A VM or Server sends an Ethernet frame. For example, Host (A) ⟶ Host (B).<li>The frame reaches the local VTEP (VXLAN Tunnel Endpoint).</ul><h4 id="setup-2-encapsulation">Setup (2): Encapsulation</h4><ul><li>The VTEP checks the VNI (VXLAN Network Identifier) and destination MAC address.<li>It then encapsulates the frame inside a UDP/IP packet:<ul><li>Outer Source IP: Local VTEP IP <code class="language-plaintext highlighter-rouge">10.0.0.100</code><li>Outer Destination IP: Remote VTEP IP <code class="language-plaintext highlighter-rouge">10.0.0.200</code><li>VNI: <code class="language-plaintext highlighter-rouge">100</code> (For example, <code class="language-plaintext highlighter-rouge">100</code>)<li>UDP Port: 4789 (The default VXLAN UDP port is <code class="language-plaintext highlighter-rouge">4789</code>)</ul></ul><h4 id="setup-3-underlay-forwarding">Setup (3): Underlay Forwarding</h4><ul><li>The encapsulated packet is sent over the physical (underlay) network.</ul><h4 id="setup-4-decapsulation-at-remote-vtep">Setup (4): Decapsulation at Remote VTEP</h4><ul><li>The remote VTEP (<code class="language-plaintext highlighter-rouge">10.0.0.200</code>) receives the packet.<li>Then, it checks the following:<ul><li>UDP Port: <code class="language-plaintext highlighter-rouge">4789</code> ⟶ identifies it as VXLAN.<li>VNI: <code class="language-plaintext highlighter-rouge">100</code> ⟶ determines which virtual network it belongs to.<li>The ethernet frame is delivered to the correct destination VM or server.</ul></ul><hr /><h2 id="multi-host-container-networking-from-scratch">Multi-Host Container Networking from Scratch</h2><p>In this section, I will focus on configuring the network for <em>Two Containers — Container A and Container B</em>, running on Two Different VMs (Hosts) to communicate with each other. Make sure you have two Linux VMs or servers. In this article, I will use two AWS EC2 Instances to demonstrate how Multi-Host Container networking works using the VXLAN networking mode.</p><p>Our project setup looks like this. Container A and Container B are running on Two different hosts.</p><ul><li>Container A (<code class="language-plaintext highlighter-rouge">10.0.0.100</code>) on Host (1) — Debian Linux VM (<code class="language-plaintext highlighter-rouge">172.31.89.40</code>)<li>Container B (<code class="language-plaintext highlighter-rouge">10.0.0.200</code>) on Host (2) — Amazon Linux VM (<code class="language-plaintext highlighter-rouge">172.31.94.69</code>)</ul><h3 id="how-it-works">How it Works</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/featured-images/img_multi_host_container_networking.png" alt="Multi-Host Container Networking Diagram" /> <em>Diagram on How Multi-Host Container Networking Works</em></p><ul><li><p><em>Container (A)</em> and <em>Container (B)</em> are running on two different hosts (Host 1 and Host 2).</p><li><p>VETH (Virtual Ethernet) pair <code class="language-plaintext highlighter-rouge">veth0</code>,<code class="language-plaintext highlighter-rouge">veth1</code> that connects the network between Host and Container in the same Linux network namespace. <code class="language-plaintext highlighter-rouge">veth0</code> on the Host machine and <code class="language-plaintext highlighter-rouge">veth1</code> on the container.</p><li><p>VXLAN (Virtual eXtensible Local-Area Network) creates a tunnel that connects Host (1) — Debian Linux VM and Host (2) — Amazon Linux VM.</p><li><p>Then, the Bridge network <code class="language-plaintext highlighter-rouge">br0</code> is a network switch that forwards network packets between VXLAN and VETH network interfaces. Then, Container (A) and Container (B) can communicate with each other.</p></ul><p><em>In the next section, you’ll learn how to set up and configure the network in more detail.</em></p><hr /><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/featured-images/img_multi_host_container_net_host1.png" alt="Host 1" /></p><h3 id="on-host-1-debian-linux-vm">On Host (1) Debian Linux VM</h3><h4 id="configuring-container-network">Configuring Container Network</h4><p>Firstly, I will set up and configure the network for Container A on Host (1) — Debian Linux. For running Containers, we will use the Alpine Linux root filesystem image.</p><p>Make sure you familiar with how to run a Container from scratch with unshare, chroot tools and you’ve learned how to run it in the previous article, Part I — Containers from Scratch: Deep Dive into Single-Host Container Networking.</p><p>Create a project directory and download the Alpine Linux root filesystem image. This setup is same as the previous (Part I) article.</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">mkdir</span> <span class="nt">-p</span> containers/alpine-linux
<span class="nv">$ </span>curl <span class="nt">-LO</span> https://dl-cdn.alpinelinux.org/alpine/v3.21/releases/x86_64/alpine-minirootfs-3.21.3-x86_64.tar.gz
</pre></table></code></div></div><p>Extract the alpine-minirootfs-3.21.3-x86_64.tar.gz tar file and clean up.</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">tar</span> <span class="nt">-xzvf</span> alpine-minirootfs-3.21.3-x86_64.tar.gz
<span class="nv">$ </span><span class="nb">rm </span>alpine-minirootfs-3.20.2-x86_64.tar.gz
</pre></table></code></div></div><p>Project structure looks like this:</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>~/containers/alpine-linux
 ├── bin
 ├── dev
 ├── etc
 ├── home
 ├── lib
 ├── media
 ├── mnt
 ├── opt
 ├── proc
 ├── root
 ├── run
 ├── sbin
 ├── srv
 ├── sys
 ├── tmp
 ├── usr
 └── var
</pre></table></code></div></div><p>I will create and run Container A in an isolated PID (Process ID), mount, and network namespaces using the command-line tools, unshare, chroot.</p><blockquote><p>The following command creates a Container (Container A) that is fully PID, mount, and network isolated from the Host (OS) machine and then mounts the /proc virtual filesystem.</p></blockquote><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">cd</span> ~/containers/alpine-linux
<span class="nv">$ </span><span class="nb">sudo </span>unshare <span class="nt">--pid</span> <span class="nt">--mount</span> <span class="nt">--net</span> <span class="se">\</span>
     <span class="nt">-f</span> <span class="nb">chroot</span> ./  <span class="se">\</span>
     <span class="nb">env</span> <span class="nt">-i</span> <span class="nv">HOSTNAME</span><span class="o">=</span>alpine-linux <span class="se">\</span>
     /bin/sh <span class="nt">-c</span> <span class="s2">"mount -t proc proc /proc; exec /bin/sh;"</span>
</pre></table></code></div></div><p>Then, open another terminal on the your Host machine and get the container process ID with the following command.</p><blockquote><p>The following command gets the current running container’s PID and sets the environment variable and then I will use this ENV variable when configuring the container network.</p></blockquote><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">export </span><span class="nv">CONTAINER_PID</span><span class="o">=</span><span class="si">$(</span>ps <span class="nt">-C</span> sh <span class="nt">-o</span> <span class="nv">pid</span><span class="o">=</span> | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s1">' '</span><span class="si">)</span>
</pre></table></code></div></div><p>Then, create a VETH (Virtual Ethernet) network pair veth0, veth1 with the ip command-line tool.</p><blockquote><p>The following command creates a VETH pair veth0, veth1 and sets veth1 to the network namespace with the current running container PID and then brings veth0 up. The VETH device is like a local Ethernet tunnel, and a VETH pair consists of two interfaces — one in the host machine’s network namespace and another one in the container’s network namespace. In the above example, veth0 is in the host machine’s Net namespace and veth1 is in the container’s Net namesapce.</p></blockquote><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>ip <span class="nb">link </span>add veth0 <span class="nb">type </span>veth peer name veth1
<span class="nb">sudo </span>ip <span class="nb">link set </span>veth1 netns <span class="k">${</span><span class="nv">CONTAINER_PID</span><span class="k">}</span>
<span class="nb">sudo </span>ip <span class="nb">link set </span>dev veth0 up
</pre></table></code></div></div><p>Then, set the IP address of Container A by running the following command without entering into the container’s shell.</p><blockquote><p>The following command sets the IP address 10.0.0.100 to the veth1 network interface, also known as Container A’s IP address and brings lo, veth1 up. You can use nsenter to exec commands without entering the container’s shell.</p></blockquote><p><strong>Container A’s IP address</strong> ⟶ <code class="language-plaintext highlighter-rouge">10.0.0.100</code></p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>nsenter <span class="nt">--target</span> <span class="k">${</span><span class="nv">CONTAINER_PID</span><span class="k">}</span> <span class="se">\</span>
  <span class="nt">--mount</span> <span class="se">\</span>
  <span class="nt">--net</span> <span class="se">\</span>
  <span class="nt">--pid</span> <span class="se">\</span>
  <span class="nb">chroot</span> <span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/containers/alpine-linux <span class="se">\</span>
  /bin/sh <span class="nt">-c</span> <span class="s2">"ip addr add dev veth1 10.0.0.100/24; ip link set lo up; ip link set veth1 up"</span>
</pre></table></code></div></div><p>Then, I will create a bridge network and attach veth0 to the bridge network with the following command.</p><blockquote><p>The following command creates a Bridge network interface named <code class="language-plaintext highlighter-rouge">br0</code>, attaches <code class="language-plaintext highlighter-rouge">veth0</code> to the <code class="language-plaintext highlighter-rouge">br0</code> bridge interface, sets the IP address, and brings it up. Make sure you create and configure the bridge network because we need to communicate between the Container and the Host machine. A bridge network is like a network switch that forwards packets between network interfaces that are connected to it.</p></blockquote><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">sudo </span>ip <span class="nb">link </span>add br0 <span class="nb">type </span>bridge
<span class="nv">$ </span><span class="nb">sudo </span>ip <span class="nb">link set </span>veth0 master br0
<span class="nv">$ </span><span class="nb">sudo </span>ip addr add dev br0 10.0.0.1/24
<span class="nv">$ </span><span class="nb">sudo </span>ip <span class="nb">link set </span>br0 up
</pre></table></code></div></div><h4 id="configuring-vxlan-network-interface">Configuring VXLAN Network Interface</h4><p>In this section, I will set up and configure VXLAN to create a tunnel between <em>Host (1) — Debian Linux VM</em> and <em>Host (2) — Amazon Linux VM</em>, and then you can communicate between Container A and Container B.</p><p>On the <strong>Host (1) Debian Linux VM</strong>, create a VXLAN interface with the ip command-line tool.</p><blockquote><p>The following command creates a VXLAN interface named <code class="language-plaintext highlighter-rouge">vxlan0</code> and brings it up. It creates a tunnel and connects two VMs or servers. Host (1) — Debian Linux VM (<code class="language-plaintext highlighter-rouge">172.31.89.40</code>) is local and Host (2) — Amazon Linux VM (<code class="language-plaintext highlighter-rouge">172.31.94.69</code>) is remote. Make sure you set the same VNI (id) on both Host (1) and Host (2).</p></blockquote><ul><li>Local IP Address ⟶ <code class="language-plaintext highlighter-rouge">172.31.89.40</code> (Debian Linux VM)<li>Remote IP Address ⟶ <code class="language-plaintext highlighter-rouge">172.31.94.69</code> (Amazon Linux VM)<li>VXLAN Network Identifier (VNI) ⟶ <code class="language-plaintext highlighter-rouge">100</code><li>Destination Port⟶ <code class="language-plaintext highlighter-rouge">4789</code> (Default UDP Port)<li>Network Interface (Device) ⟶ <code class="language-plaintext highlighter-rouge">enX0</code> (Ethernet network device on the Debian Linux VM)</ul><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>ip <span class="nb">link </span>add vxlan0 <span class="se">\</span>
  <span class="nb">type </span>vxlan <span class="se">\</span>
  <span class="nb">id </span>100 <span class="se">\</span>
  <span class="nb">local </span>172.31.89.40 <span class="se">\</span>
  remote 172.31.94.69 <span class="se">\</span>
  dstport 4789 <span class="se">\</span>
  dev enX0 <span class="o">&amp;&amp;</span> <span class="se">\</span>
<span class="nb">sudo </span>ip <span class="nb">link set </span>vxlan0 up
</pre></table></code></div></div><p>Then, attach the <code class="language-plaintext highlighter-rouge">vxlan0</code> interface to the bridge network device with the following command.</p><blockquote><p>The following command attaches the vxlan0 interface to the br0 bridge network device. Previously, we’ve created this bridge device and make sure you attach your VXLAN interface to the bridge network device. We need to forward packets or connect the VETH and VXLAN interfaces because it’s necessary to communicate between Container A (running on Host 1) and Container B (running on Host 2).</p></blockquote><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>ip <span class="nb">link set </span>vxlan0 master br0
</pre></table></code></div></div><p>Then, you can check it with the brctl command-line tool. Make sure your veth0 and vxlan0 are attached to the bridge br0 device.</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>brctl show
bridge name     bridge <span class="nb">id               </span>STP enabled     interfaces
br0             8000.8aea1d11531b       no              veth0
                                                        vxlan0
</pre></table></code></div></div><hr /><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/featured-images/img_multi_host_container-net_host2.png" alt="Host 2" /></p><h3 id="on-host-2-amazon-linux-vm">On Host (2) Amazon Linux VM</h3><h4 id="configuring-container-network-1">Configuring Container Network</h4><p>Same as the previous Host (1) setup, I will set up and configure the network for <strong>Container B</strong> on <strong>Host (2) — Amazon Linux</strong>. To create and run the container, we will use the Alpine Linux root filesystem image.</p><p>Create a project directory and download the Alpine Linux root filesystem image. This setup is same as the previous (Part I) article.</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">mkdir</span> <span class="nt">-p</span> containers/alpine-linux
<span class="nv">$ </span>curl <span class="nt">-LO</span> https://dl-cdn.alpinelinux.org/alpine/v3.21/releases/x86_64/alpine-minirootfs-3.21.3-x86_64.tar.gz
</pre></table></code></div></div><p>Extract the alpine-minirootfs-3.21.3-x86_64.tar.gz tar file and clean up.</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">tar</span> <span class="nt">-xzvf</span> alpine-minirootfs-3.21.3-x86_64.tar.gz
<span class="nv">$ </span><span class="nb">rm </span>alpine-minirootfs-3.20.2-x86_64.tar.gz
</pre></table></code></div></div><p>Project structure looks like this:</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>~/containers/alpine-linux
 ├── bin
 ├── dev
 ├── etc
 ├── home
 ├── lib
 ├── media
 ├── mnt
 ├── opt
 ├── proc
 ├── root
 ├── run
 ├── sbin
 ├── srv
 ├── sys
 ├── tmp
 ├── usr
 └── var
</pre></table></code></div></div><p>I will create and run <strong>Container B</strong> in an isolated PID (Process ID), mount, and network namespaces using the command-line tools, unshare, chroot.</p><blockquote><p>This command creates a Container (Container B) that is fully PID, mount, and network isolated from the Host (OS) machine and then mounts the <code class="language-plaintext highlighter-rouge">/proc</code> virtual filesystem.</p></blockquote><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">cd</span> ~/containers/alpine-linux
<span class="nv">$ </span><span class="nb">sudo </span>unshare <span class="nt">--pid</span> <span class="nt">--mount</span> <span class="nt">--net</span> <span class="se">\</span>
     <span class="nt">-f</span> <span class="nb">chroot</span> ./  <span class="se">\</span>
     <span class="nb">env</span> <span class="nt">-i</span> <span class="nv">HOSTNAME</span><span class="o">=</span>alpine-linux <span class="se">\</span>
     /bin/sh <span class="nt">-c</span> <span class="s2">"mount -t proc proc /proc; exec /bin/sh;"</span>
</pre></table></code></div></div><p>Then, open another terminal on the your Host machine and get the container process ID with the following command.</p><blockquote><p>This command gets the current running container’s PID and sets the environment variable and then I will use this ENV variable when configuring the container network.</p></blockquote><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">export </span><span class="nv">CONTAINER_PID</span><span class="o">=</span><span class="si">$(</span>ps <span class="nt">-C</span> sh <span class="nt">-o</span> <span class="nv">pid</span><span class="o">=</span> | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s1">' '</span><span class="si">)</span>
</pre></table></code></div></div><p>Then, create a VETH (Virtual Ethernet) network pair veth0, veth1 with the ip command-line tool.</p><blockquote><p>This command creates a VETH pair veth0, veth1 and sets veth1 to the network namespace with the current running container PID and then brings veth0 up. The VETH device is like a local Ethernet tunnel, and a VETH pair consists of two interfaces — one in the host machine’s network namespace and another one in the container’s network namespace. In the above example, veth0 is in the host machine’s Net namespace and veth1 is in the container’s Net namesapce.</p></blockquote><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>ip <span class="nb">link </span>add veth0 <span class="nb">type </span>veth peer name veth1
<span class="nb">sudo </span>ip <span class="nb">link set </span>veth1 netns <span class="k">${</span><span class="nv">CONTAINER_PID</span><span class="k">}</span>
<span class="nb">sudo </span>ip <span class="nb">link set </span>dev veth0 up
</pre></table></code></div></div><p>Then, set the IP address of Container B by running the following command without entering into the container’s shell.</p><blockquote><p>This command sets the IP address <code class="language-plaintext highlighter-rouge">10.0.0.200</code> to the veth1 network interface, also known as Container B’s IP address and brings lo, veth1 up. You can use nsenter to exec commands without entering the container’s shell.</p></blockquote><p><strong>Container B’s IP address</strong> ⟶ <code class="language-plaintext highlighter-rouge">10.0.0.200</code></p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>nsenter <span class="nt">--target</span> <span class="k">${</span><span class="nv">CONTAINER_PID</span><span class="k">}</span> <span class="se">\</span>
  <span class="nt">--mount</span> <span class="se">\</span>
  <span class="nt">--net</span> <span class="se">\</span>
  <span class="nt">--pid</span> <span class="se">\</span>
  <span class="nb">chroot</span> <span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/containers/alpine-linux <span class="se">\</span>
  /bin/sh <span class="nt">-c</span> <span class="s2">"ip addr add dev veth1 10.0.0.200/24; ip link set lo up; ip link set veth1 up"</span>
</pre></table></code></div></div><p>Then, I will create a bridge network and attach <code class="language-plaintext highlighter-rouge">veth0</code> to the bridge network with the following command.</p><blockquote><p>This command creates a Bridge network interface named <code class="language-plaintext highlighter-rouge">br0</code>, attaches <code class="language-plaintext highlighter-rouge">veth0</code> to the <code class="language-plaintext highlighter-rouge">br0</code> bridge interface, sets the IP address, and brings it up. Make sure you create and configure the bridge network because we need to communicate between the Container and the Host machine. A bridge network is like a network switch that forwards packets between network interfaces that are connected to it.</p></blockquote><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">sudo </span>ip <span class="nb">link </span>add br0 <span class="nb">type </span>bridge
<span class="nv">$ </span><span class="nb">sudo </span>ip <span class="nb">link set </span>veth0 master br0
<span class="nv">$ </span><span class="nb">sudo </span>ip addr add dev br0 10.0.0.2/24
<span class="nv">$ </span><span class="nb">sudo </span>ip <span class="nb">link set </span>br0 up
</pre></table></code></div></div><h4 id="configuring-vxlan-network-interface-1">Configuring VXLAN Network Interface</h4><p>In this section, I will set up and configure VXLAN to create a tunnel between <em>Host (1) — Debian Linux VM</em> and <em>Host (2) — Amazon Linux VM</em>, and then you can communicate between <em>Container A</em> and <em>Container B</em>.</p><p>Same as the previous Host (1) setup, on the <strong>Host (2) Amazon Linux VM</strong>, create a VXLAN interface with the ip command-line tool.</p><blockquote><p>This command creates a VXLAN interface named vxlan0 and brings it up. It creates a tunnel and connects two VMs or servers. In this setup, Host (2) — Amazon Linux VM (172.31.94.69) is local and Host (1) — Debian Linux VM (172.31.89.40) is remote. Make sure you set the same VNI (id) on both Host (1) and Host (2).</p></blockquote><ul><li>Local IP Address ⟶ <code class="language-plaintext highlighter-rouge">172.31.94.69</code> (Host 2 Amazon Linux VM)<li>Remote IP Address ⟶ <code class="language-plaintext highlighter-rouge">172.31.89.40</code> (Host 1 Debian Linux VM)<li>VXLAN Network Identifier (VNI) ⟶ <code class="language-plaintext highlighter-rouge">100</code><li>Destination Port ⟶ <code class="language-plaintext highlighter-rouge">4789</code> (Default UDP Port)<li>Network Interface (Device) ⟶ <code class="language-plaintext highlighter-rouge">enX0</code> (Ethernet network device on the Host 2 Amazon Linux VM)</ul><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>ip <span class="nb">link </span>add vxlan0 <span class="se">\</span>
  <span class="nb">type </span>vxlan <span class="se">\</span>
  <span class="nb">id </span>100 <span class="se">\</span>
  <span class="nb">local </span>172.31.94.69 <span class="se">\</span>
  remote 172.31.89.40 <span class="se">\</span>
  dstport 4789 <span class="se">\</span>
  dev enX0 <span class="o">&amp;&amp;</span> <span class="se">\</span>
<span class="nb">sudo </span>ip <span class="nb">link set </span>vxlan0 up
</pre></table></code></div></div><p>Then, attach the <code class="language-plaintext highlighter-rouge">vxlan0</code> interface to the bridge network device with the following command.</p><blockquote><p>This command attaches the <code class="language-plaintext highlighter-rouge">vxlan0</code> interface to the <code class="language-plaintext highlighter-rouge">br0</code> bridge network device. Previously, we’ve created this bridge device and make sure you attach your VXLAN interface to the bridge network device. We need to forward packets or connect the VETH and VXLAN interfaces because it’s necessary to communicate between Container A (running on Host 1) and Container B (running on Host 2).</p></blockquote><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>ip <span class="nb">link set </span>vxlan0 master br0
</pre></table></code></div></div><p>Then, you can check it with the brctl command-line tool. Make sure your <code class="language-plaintext highlighter-rouge">veth0</code> and <code class="language-plaintext highlighter-rouge">vxlan0</code> are attached to the bridge <code class="language-plaintext highlighter-rouge">br0</code> device.</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>brctl show
bridge name     bridge <span class="nb">id               </span>STP enabled     interfaces
br0             8000.8aea1d11531b       no              veth0
                                                        vxlan0
</pre></table></code></div></div><hr /><h2 id="testing-network-connectivity">Testing Network Connectivity</h2><p>Now, you’ve configured the container network and VXLAN tunnel, and you can ping the containers’ IP addresses to confirm if it works.</p><p>Ping Container A (<code class="language-plaintext highlighter-rouge">10.0.0.100</code>) from the Host 2 (Amazon Linux VM).</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ping 10.0.0.100
</pre></table></code></div></div><p>Ping Container B (<code class="language-plaintext highlighter-rouge">10.0.0.200</code>) from the Host 1 (Debian Linux VM).</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ping 10.0.0.200
</pre></table></code></div></div><p>Reference Links:</p><ul><li><a href="https://blog.mbrt.dev/posts/container-network">https://blog.mbrt.dev/posts/container-network</a><li><a href="https://labs.iximiuz.com/tutorials/container-networking-from-scratch">https://labs.iximiuz.com/tutorials/container-networking-from-scratch</a><li><a href="https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking">https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/containerization/'>Containerization</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/containerization/" class="post-tag no-text-decoration" >containerization</a> <a href="/tags/containers/" class="post-tag no-text-decoration" >containers</a> <a href="/tags/networking/" class="post-tag no-text-decoration" >networking</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Containers from Scratch: Deep Dive into Multi-Host Container Networking (Part II) - Zaw Zaw&url=https://zawzaw.blog/posts/deep-dive-multi-host-container-net/" data-toggle="tooltip" data-placement="top" title="X (Twitter)" target="_blank" rel="noopener" aria-label="X (Twitter)"> <i class="fa-fw fab fa-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Containers from Scratch: Deep Dive into Multi-Host Container Networking (Part II) - Zaw Zaw&u=https://zawzaw.blog/posts/deep-dive-multi-host-container-net/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://zawzaw.blog/posts/deep-dive-multi-host-container-net/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2" style="font-size: large;">Table of Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Related Posts</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/deep-dive-single-host-container-net/"><div class="card-body"> <span class="timeago small" > Mar 15 <i class="unloaded">2025-03-15T00:00:00+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Containers from Scratch: Deep Dive into Single-Host Container Networking</h3><div class="text-muted small"><p> This article focused on a deep dive into Container networking; how to run Containers and configure Container Networking from scratch using the tools, such as Linux Namespaces, chroot, unshare and i...</p></div></div></a></div><div class="card"> <a href="/posts/guide-k8s-persistent-storage/"><div class="card-body"> <span class="timeago small" > Jan 31 <i class="unloaded">2025-01-31T00:00:00+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>A Hands-on Practical Guide to K8s Persistent Storage</h3><div class="text-muted small"><p> In Kubernetes, we typically need to create and use Persistent Volumes for stateful applications such as database servers, cache store servers, and so on. In this article, I will share how storage p...</p></div></div></a></div><div class="card"> <a href="/posts/configure-k8s-auth-rbac/"><div class="card-body"> <span class="timeago small" > Dec 5, 2024 <i class="unloaded">2024-12-05T00:00:00+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Configuring RBAC Role Bindings for a User on Kubernetes</h3><div class="text-muted small"><p> This article focuses on how to create a user and configure cluster roles and role bindings for that user using Kubernetes built-in RBAC authorization features. Basically, in Kubernetes, we can use ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/deep-dive-single-host-container-net/" class="btn btn-outline-primary" prompt="Older"><p>Containers from Scratch: Deep Dive into Single-Host Container Networking</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025, <a href="https://github.com/zawzaww">Zaw Zaw</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) by the author.">Licensed under CC BY 4.0.</span></p></div><div class="footer-right"><p class="mb-0"> <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">CHIRPY Theme</a> &mdash; <a href="https://jekyllrb.com" target="_blank" rel="noopener"> Powered byJekyll</a></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/aosp/">aosp</a> <a class="post-tag" href="/tags/build/">build</a> <a class="post-tag" href="/tags/containerization/">containerization</a> <a class="post-tag" href="/tags/containers/">containers</a> <a class="post-tag" href="/tags/networking/">networking</a> <a class="post-tag" href="/tags/asia/">asia</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://zawzaw.blog{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
